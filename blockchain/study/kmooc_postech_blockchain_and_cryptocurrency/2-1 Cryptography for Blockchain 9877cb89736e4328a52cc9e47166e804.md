# 2-1  Cryptography for Blockchain

- 해시 함수 특징
- 포인터 / 리스트

1. 해시 함수 
    
    특징 1. 메시지 축약
    
    입력값으로 어떤 데이터를 넣더라도 동일한 사이즈의 출력값을 낸다
    
    ![스크린샷 2022-01-22 07.38.48.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_07.38.48.png)
    
    입력값 X 를 넣으면 Y를 얻을 수 있음
    
    SHA265함수라면, 어떤 글자를 넣더라도 32byte 의 값을 냄
    
    단방향
    
    특징 2. Collision-free
    
    발생할 충돌로부터 자유로울 수 있다는 뜻
    
    ![스크린샷 2022-01-22 07.40.00.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_07.40.00.png)
    
    input 값들이 ouput값의 종류보다 더 많다면, input 값들의 값이 중복
    
    특징 3. 비대칭성
    
    y 값으로 x 값을 추론할 수 없음
    
    ![스크린샷 2022-01-22 07.44.23.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_07.44.23.png)
    
    자신이 공개하길 원하지 않을 경우, 타인이 볼 수 없게 할 수 있음
    
    → 공개키에서 주소를 만들 때, 암호화 해시 함수를 이용하는 이유
    
2. 해시함수 종류
    1. SHA, secure hash algorithm
        1. 256 비트 길이의 출력값을 생성
        2. 비트코인은 SHA-256 함수를 생성
    2. Keccak 256
        1. 265bit 출력값을 생성
        2. 이더리움에서 사용하는 해시함수
        3. 처음 96비트를 버리고 마지막 160비트를 사용
        4. SHA-3 표준으로 정의
3. 자료구조-해시포인터
    - 정보가 저장된 곳을 가리키는 포인터
        - 해시가 가리키고 잇는 데이터가 변경되었는지 확인하기 위함
    - 마지막으로 기억하는 데이터의 해시값
    - 데이터가 변경되면 데이터의 해시값이 변하기에, 해시 포인터가 가리키는 해시값과 데이터의 해시결과가 일치하지 않음
    
    → 이를 통해 데이터의 위변조 검사가 가능
    
    linked list 로 연결된 모든 블록은 이전 블록을 가르키는 포인터를 가지고 있음
    
    수정할 시 이전 데이터와 맞지 않게 됨
    
    ![스크린샷 2022-01-22 07.57.34.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_07.57.34.png)
    
4. 암호화 기법
    
    암호화 encryption 
    
    복호화 decryption
    
    대칭키 알고리즘
    
    ![스크린샷 2022-01-22 07.59.45.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_07.59.45.png)
    
    - 암호화-복호화 시 동일한 대칭키를 사용
    - 상대적으로 계산속도가 빠름
    - 트리플데스3DES, AES
    
    비대칭키 알고리즘
    
    ![스크린샷 2022-01-22 08.00.50.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_08.00.50.png)
    
    - 공개키, 대칭키 2가지 사용
    - 공개키를 사용해 암호화 하고, 개인키를 사용해 원본 데이터를 암호화
    - 전자 서명을 위해 개인키로 암호화된 문서를 제공, 공개키로 이 문서를 복호화 해서 풀리면 전달받은 데이터가 해당 사용자가 보낸 문서임을 증명 가능
    - 대표적으로 RSA
    
5. 디지털 서명
    - 문서에 하는 인감 날인, 사인에 해당하는 기능을 컴퓨터 세계에서 실현하기 위한 기술
    - 서명과 인증 두 과정으로 나뉨
    - 서명은 해당 문서의 유효성을 검증할 수 있도록 문서의 작성자가 서명을 생성하는 과정
    - 인증은 해당 문서에 대한 서명이 유효한지 검증하는 과정
    - 메시지에 서명할 때 개인키만을 사용
    
    1. 위조 불가 No forgery : 본인 외에는 아무도 흉내내서는 안됨
    2. 인증 Authentication : 나의 것인지 확인할 수 있어야함
    3. 재사용불가 No re-use : 다른 문서 내에서 떼어 붙이는 경우, 효력이 없음
    4. 변경 불가 Unchangeable : 서명된 문서에 관한 내용 변경이 불가, 내용 변경 시 서명 당시의 데이터와 다르다는 것을 알아야 함
    5. 부인 방지 Non-repudiation : 서명한 이후 나중에 부인할 수 없음
    
6. 서명 구성 2가지
    
    
    - 서명 Signing
        - 문서가 검증되었음을 알림
        
        ![스크린샷 2022-01-22 08.06.55.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_08.06.55.png)
        
        1. 엘리스는 자신의 개인 키를 이용해 메시지에 서명
            
            원본 데이터 자체를 암호화 하는 것이 아니라, 해시 함수를 이용해 해시한 메시지에 개인키로 서명을 하여 암호화
            
            앨리스의 개인키로 서명된 문서는 앨리스의 공개키를 이용해서만 복호화 가능
            
        2. 앨리스는 암호화된 해시 데이터와 원본 데이터를 밥에게 보냄
    
    - 인증 Verification
        - 해당 문서에 서명이 되었는지를 확인
            
            ![스크린샷 2022-01-22 08.07.49.png](2-1%20Cryptography%20for%20Blockchain%209877cb89736e4328a52cc9e47166e804/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-01-22_08.07.49.png)
            
            1. 진짜 앨리스가 서명한 문서인지 검증하기 위해, 서명 부분을 따로 떼내어 엘리스의 공개키로 복호화
            2. 서명된 문서와 함께 전달받은 원본 데이터를 앨리스가 사용한 것과 동일한 해시 함수를 이용하여 해싱
                
                원본데이터의 해시값 =? 앨리스의 서명을 앨리스 공개키를 이용해 복호화한 값 → 일치하면 앨리스에 의해 서명된 문서 
                
    
    오직 자신의 개인 키를 가지고 서명하기 때문에, 분실하지 않도록 주의해야 함
    
7. 디지털 서명을 위한 API , 3가지 동작
    1. generateKeys : 개인키 - 공개키로 이루어진 키 쌍을 만듦
        
        sk, secret signing key : 서명에 사용되는 개인 키
        
        pk, public verification key : 검증에 사용되는 공개키
        
    2. 함수 sign : 서명을 위한 함수
        
        개인키 sk, 
        
        원본 메시지를 인자로 넣으면 sig 라고 하는 서명을 반환
        
    3. 함수 verify : 검증을 위한 함수 
        
        유효한 서명인지 아닌지 확인하고자 하는 sig
        
        +
        
        원본메시지
        
        +
        
        개인키로 서명된 원본 데이터로 풀기 위한 공개키인 pk